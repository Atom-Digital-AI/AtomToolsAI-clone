import { eq, and, isNull } from "drizzle-orm";
import { createHash } from "crypto";
import { db } from "../db";
import { apiKeys } from "@shared/schema";

/**
 * API Key Repository
 * Handles all API key-related database operations
 */
export const apiKeyRepository = {
  /**
   * Hash an API key for storage
   */
  hashKey(key: string): string {
    return createHash("sha256").update(key).digest("hex");
  },

  /**
   * Get API key prefix (first 8 characters for identification)
   */
  getKeyPrefix(key: string): string {
    return key.substring(0, 8);
  },

  /**
   * Find an API key by its hash
   */
  async findByHash(keyHash: string): Promise<typeof apiKeys.$inferSelect | undefined> {
    const [apiKey] = await db
      .select()
      .from(apiKeys)
      .where(and(eq(apiKeys.keyHash, keyHash), isNull(apiKeys.revokedAt)));
    return apiKey || undefined;
  },

  /**
   * Find all API keys for a user
   */
  async findByUserId(userId: string): Promise<(typeof apiKeys.$inferSelect)[]> {
    return await db
      .select()
      .from(apiKeys)
      .where(and(eq(apiKeys.userId, userId), isNull(apiKeys.revokedAt)));
  },

  /**
   * Create a new API key
   * Note: The actual key should be generated by the caller and returned to user only once
   */
  async create(
    userId: string,
    name: string,
    key: string,
    options?: {
      scopes?: string[];
      rateLimit?: number;
      expiresAt?: Date;
    }
  ): Promise<typeof apiKeys.$inferSelect> {
    const keyHash = this.hashKey(key);
    const keyPrefix = this.getKeyPrefix(key);

    const [newKey] = await db
      .insert(apiKeys)
      .values({
        userId,
        name,
        keyHash,
        keyPrefix,
        scopes: options?.scopes || [],
        rateLimit: options?.rateLimit || 100,
        expiresAt: options?.expiresAt || null,
      })
      .returning();

    return newKey;
  },

  /**
   * Update the last used timestamp
   */
  async updateLastUsed(id: string): Promise<void> {
    await db
      .update(apiKeys)
      .set({ lastUsedAt: new Date() })
      .where(eq(apiKeys.id, id));
  },

  /**
   * Revoke an API key
   */
  async revoke(id: string, userId: string): Promise<boolean> {
    const result = await db
      .update(apiKeys)
      .set({ revokedAt: new Date() })
      .where(and(eq(apiKeys.id, id), eq(apiKeys.userId, userId)));
    return (result.rowCount ?? 0) > 0;
  },

  /**
   * Check if an API key is valid (not expired, not revoked)
   */
  async validate(key: string): Promise<{
    valid: boolean;
    apiKey?: typeof apiKeys.$inferSelect;
    reason?: string;
  }> {
    const keyHash = this.hashKey(key);
    const apiKey = await this.findByHash(keyHash);

    if (!apiKey) {
      return { valid: false, reason: "API key not found" };
    }

    if (apiKey.revokedAt) {
      return { valid: false, reason: "API key has been revoked" };
    }

    if (apiKey.expiresAt && apiKey.expiresAt < new Date()) {
      return { valid: false, reason: "API key has expired" };
    }

    // Update last used timestamp
    await this.updateLastUsed(apiKey.id);

    return { valid: true, apiKey };
  },

  /**
   * Delete an API key permanently
   */
  async delete(id: string, userId: string): Promise<boolean> {
    const result = await db
      .delete(apiKeys)
      .where(and(eq(apiKeys.id, id), eq(apiKeys.userId, userId)));
    return (result.rowCount ?? 0) > 0;
  },
};
